# CLAUDE.md - AI Agent Documentation

## Important Notes for AI Agents

**‚ö†Ô∏è CRITICAL: When reading project assets, follow these rules:**
- **ONLY read image and audio file NAMES and FOLDERS**
- **NEVER read the actual CONTENT of image files** (`.png`, `.jpg`, `.jpeg`, `.gif`, `.bmp`, etc.)
- **NEVER read the actual CONTENT of audio files** (`.mp3`, `.wav`, `.ogg`, `.m4a`, etc.)
- Reading image/audio content wastes significant tokens without providing useful information
- Focus on C# scripts, prefabs, and scene files for understanding the project

---

## Project Overview

**2D Chess-Meets-Shooter Mobile Game**

This Unity 2D project is a hybrid tactical game combining:
1. **Chess Mode**: Hexagonal grid-based tactical movement with opponent AI
2. **Standoff Mode**: 2D side-scrolling platformer with shooting mechanics and SUPERHOT-style slow motion

**Unity Version**: 6000.4.0a4

**Game Inspirations:**
- **Shotgun King: The Final Checkmate** - Chess mechanics reversed (player is the pawn, opponent is the shotgun king)
- **Fights in Tight Spaces** - Enemy modifiers and tactical card-based combat
- **SUPERHOT** - Time manipulation mechanics (time moves when you move)
- **Terraria** - Side-scrolling platformer combat style

---

## Game Flow

```
Main Menu
    ‚Üì
Level Selection
    ‚Üì
Chess Mode (Hex Grid)
    ‚Üí Player: Swipe to move in 6 hex directions
    ‚Üí Opponents: AI-driven pawns with guns (Basic, Handcannon, Shotgun, Sniper)
    ‚Üí Combat: Walk onto opponent to capture, opponents shoot at player
    ‚Üì
(When only 1 opponent remains)
    ‚Üì
Standoff Mode (2D Platformer)
    ‚Üí Arena generation: Hexagonal platforms at varying heights
    ‚Üí Player: Joystick movement + jump button
    ‚Üí Opponent: AI platforming with shooting
    ‚Üí Time: Slow motion when player idle (SUPERHOT style)
    ‚Üí Win condition: Touch the opponent to capture
    ‚Üì
Victory/Defeat Screen
    ‚Üí Next level or retry
```

---

## Architecture Overview

### Core Systems (16 Consolidated Scripts)

The codebase has been consolidated from 27 scripts to 16 for better maintainability:

1. **GameManager.cs** - Unified game state and level management (merged GameStateManager + LevelManager)
   - States: MainMenu, LevelSelect, ChessMode, Standoff, Victory, Defeat, Paused
   - Handles level loading, configuration, and visual settings

2. **LevelData.cs** - ScriptableObject for level presets (3 levels)

3. **Pawn Customiser.cs** - ScriptableObject for AI behavior and modifier configurations
   - Chess mode weight configurations for all AI types
   - Standoff mode distance preferences
   - Modifier effect multipliers
   - Platformer movement and jumping parameters
   - Allows tweaking AI behavior in Unity Editor without code changes

4. **AudioManager.cs** - Singleton for music and SFX management
   - Supports fade transitions and volume control

5. **TimeController.cs** - SUPERHOT-style slow motion in Standoff mode
   - Slows time when player stops moving

6. **PawnHealth.cs** - Unified health system (merged PlayerPawn + OpponentPawn)
   - Handles HP, damage, death, and visual feedback for both player and opponents

7. **Spawner.cs** - Unified spawning (merged PlayerSpawner + PawnSpawner)
   - Spawns player at bottom-right, opponents in upper tiles with weighted probability

8. **WeaponSystem.cs** - Unified weapon handling (merged Firearm + Projectile + GunAiming)
   - Fire modes: Manual, OnLineOfSight, TrackPlayer, Timed
   - Projectile types: Single, Spread, Beam
   - Includes ProjectileBehavior as nested class

9. **InputSystem.cs** - Unified input (merged MobileInputManager + VirtualJoystick)
   - Mobile touch joystick and desktop keyboard fallback

10. **UIManager.cs** - Unified UI (merged 6 UI scripts)
   - Main menu, level select, game HUD, pause menu, victory/defeat, settings

11. **Player Controller.cs** - Player movement in both modes
    - Chess: Swipe-based hex movement
    - Standoff: Rigidbody2D platformer physics

12. **Pawn Controller.cs** - Opponent AI in both modes
    - Chess: Weighted directional decision-making
    - Standoff: Platformer AI with jump detection
    - References Pawn Customiser for behavior parameters

13. **Chequerboard.cs** - Turn-based coordination

14. **HexGrid Generator.cs** - Procedural hex grid generation

15. **Platform.cs** - Procedural Standoff arena generation

16. **Follow Camera.cs** - Orthographic camera with zoom pulse effects

---

## Game Modes

### Chess Mode

**Grid System:**
- Hexagonal grid (axial coordinates: q, r)
- Two orientations: FlatTop, PointyTop
- Generated by `HexGrid Generator.cs`

**Player:**
- `Player Controller.cs`: Swipe-based movement
- `PawnHealth.cs` (PawnType.Player): Health with sprite-based HP display
- 6-directional movement on hex grid
- Capture opponents by moving onto their tile

**Opponents:**
- `Pawn Controller.cs`: AI decision-making
- `PawnHealth.cs` (PawnType.Opponent): Health, death effects, physics expulsion
- 4 AI types:
  - **Basic**: Moves toward player (limited to 3 bottom directions, cannot move backward/upward)
  - **Handcannon**: Mid-range specialist, prefers closest tiles
  - **Shotgun**: Aggressive attacker (strongly prefers moving toward player)
  - **Sniper**: Defensive, prefers farthest tiles

**Shooting Mechanics (Chess Mode):**
- `WeaponSystem.cs`: Handles weapons, projectiles, and gun aiming
- **Basic**: No shooting (only capture by moving onto player's tile)
- **Handcannon**: Fires 1 bullet dealing 1 damage when turn starts
- **Shotgun**: Fires 3 bullets (0¬∞, +60¬∞, -60¬∞) each dealing 1 damage when turn starts
- **Sniper**: Fires 1 bullet dealing 2 damage, pierces once for 1 damage when turn starts
- All pawns with firearms fire **once when their turn starts**
- All bullets destroy on hitting chess pieces unless from Sniper or affected by modifier
- Bullets damage both player and opponents

**Shooting Mechanics (Standoff Mode):**
- Interval-based firing system:
  1. **Tracking Phase**: Pawn moves based on AI type, line-of-sight follows player with angular velocity
  2. **Firing Delay**: After fire interval, stop tracking and hold position/aim for delay time (default 0.5s)
  3. **Fire**: Shoot according to AI type and modifiers
  4. **Repeat**: Restart interval until player or pawn dies
- Gun angle matches line-of-sight angle
- Fire interval and delay are adjustable per pawn and affected by modifiers

**Opponent Modifiers:**
- Visual indicator: Modifier icon displayed at top-right of each opponent pawn
- 5 modifier types that enhance opponent capabilities:

1. **Tenacious** üõ°Ô∏è
   - Requires two captures to remove the pawn (spawns with 2 HP instead of 1)
   - Chess: Player must capture twice
   - Standoff: Takes 2 damage to defeat

2. **Confrontational** ‚öîÔ∏è
   - Chess: Shoots whenever another piece enters their line-of-sight (in addition to turn start)
   - Standoff: Reduces fire interval by 25% (fires more frequently)

3. **Fleet** üí®
   - Chess: Moves an extra time per turn (moves 2 tiles but only shoots once at turn start)
   - Standoff: Moves 25% faster

4. **Observant** üëÅÔ∏è
   - Chess: Bullets only damage the player (won't hit other opponents)
   - Standoff: Firing delay reduced by 50% (0.5s ‚Üí 0.25s)

5. **Reflexive** üéØ
   - Chess: Recalculates best aiming direction after the player moves
   - Standoff: Firearm is fixed on player (instant tracking), firing delay reduced by 25%

**Last Opponent Conversion:**
- If the last remaining opponent is **Basic** type when entering Standoff mode:
  - Inherits all stats and modifiers
  - Converts to **Handcannon** type (gains shooting ability)
  - Ensures final showdown has shooting mechanics

---

### Standoff Mode

**Arena Generation:**
- `Platform.cs`: Procedural hex-based platform generation
- Algorithm:
  1. Spawn floor tiles (6 default, with direction constraints)
  2. Generate platform 2 tiles above selected floor tile
  3. Mirror all tiles left-to-right
  4. Add 3 random connecting tiles

**Player:**
- Modified `Player Controller.cs` with platformer physics
- Rigidbody2D-based movement
- Jump mechanics with ground detection
- Mobile: Virtual joystick + jump button
- Desktop: WASD/Arrows + Space

**Opponent AI:**
- Modified `Pawn Controller.cs` with platformer AI
- Intelligent jumping (obstacles, gaps, platforms)
- Distance-based behavior:
  - Basic/Shotgun: Aggressive (always approach player)
  - Handcannon: Mid-range (maintain 2-4 unit distance)
  - Sniper: Defensive (retreat when too close)
- Edge detection to avoid falling

**Time Mechanics:**
- `TimeController.cs`: Slow motion system
- Normal time when player moves
- Slow motion (0.1x) when player idle
- Smooth transitions with adjustable speed

---

## Code Structure

### Consolidated Folder Layout
```
Assets/
‚îú‚îÄ‚îÄ Script/                    # 16 Consolidated Scripts
‚îÇ   ‚îú‚îÄ‚îÄ Core Systems:
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GameManager.cs     # Game state + Level management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LevelData.cs       # ScriptableObject
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Pawn Customiser.cs # ScriptableObject for AI behavior configs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AudioManager.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TimeController.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Gameplay:
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Player Controller.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Pawn Controller.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PawnHealth.cs      # Player + Opponent health
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Chequerboard.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HexGrid Generator.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Spawner.cs   # Player + Opponent spawning
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Platform.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WeaponSystem.cs    # Firearm + Projectile + GunAiming
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Input & UI:
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InputSystem.cs     # Mobile + Desktop input
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UIManager.cs       # All UI screens
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Utilities:
‚îÇ       ‚îî‚îÄ‚îÄ Follow Camera.cs
‚îÇ
‚îú‚îÄ‚îÄ Prefab/
‚îÇ   ‚îú‚îÄ‚îÄ Default Tile.prefab
‚îÇ   ‚îú‚îÄ‚îÄ Player Pawn.prefab
‚îÇ   ‚îú‚îÄ‚îÄ Pawn.prefab (Basic)
‚îÇ   ‚îú‚îÄ‚îÄ Pawn Hand Cannon.prefab
‚îÇ   ‚îú‚îÄ‚îÄ Pawn Shotgun.prefab
‚îÇ   ‚îî‚îÄ‚îÄ Pawn Sniper.prefab
‚îÇ
‚îú‚îÄ‚îÄ Sprite/
‚îú‚îÄ‚îÄ Audio/
‚îî‚îÄ‚îÄ Main Scene.unity
```

---

## Key Design Patterns

### 1. Singleton Pattern
Used for global managers:
- `GameManager.Instance`
- `AudioManager.Instance`
- `TimeController.Instance`
- `InputSystem.Instance`
- `UIManager.Instance`
- `Checkerboard.Instance`
- `FollowCamera.Instance`

### 2. Component-Based Architecture
Each GameObject has focused components:
- Health: `PawnHealth.cs` (with PawnType enum)
- Movement: `Player Controller.cs`, `Pawn Controller.cs`
- Weapons: `WeaponSystem.cs`

### 3. Mode Switching
Controllers support both modes:
```csharp
// Switch player to Standoff mode
playerController.SetStandoffMode(true);

// Switch opponent to Standoff mode
pawnController.SetStandoffMode(true);
weaponSystem.SetStandoffMode(true);
```

### 4. Event-Driven Communication
Using UnityEvents:
```csharp
// Health changes
PawnHealth.OnHPChanged.AddListener(OnHealthChanged);

// Game state changes
GameManager.OnStateChanged.AddListener(HandleStateChange);
GameManager.OnVictory.AddListener(ShowVictoryScreen);
```

---

## Coordinate Systems

### Chess Mode (Axial Hexagonal)
```
Axial Coordinates (q, r):
- q: Horizontal offset
- r: Vertical offset
- Neighbor deltas: {(1,0), (1,-1), (0,-1), (-1,0), (-1,1), (0,1)}

Conversion to world position:
FlatTop:
  x = sqrt(3) * tileSize * (q + r/2)
  y = (3/2) * tileSize * r

PointyTop:
  x = (3/2) * tileSize * q
  y = sqrt(3) * tileSize * (r + q/2)
```

### Standoff Mode (World Space)
- Standard Unity 2D world coordinates
- Rigidbody2D physics
- Gravity: 2f (adjustable)

---

## AI Systems

### Chess Mode AI Weights

**Basic:**
- Allowed directions: (0,-1), (-1,0), (1,-1) - bottom 3 directions only
- **Cannot move backward** (upward in world space y-axis)
- Closest to player: weight 5
- Others: weight 1
- Behaves like chess pawns (forward only, never backward)

**Handcannon:**
- All 6 directions allowed
- Closest: weight 3
- Others: weight 1
- Mid-range specialist

**Shotgun:**
- All 6 directions allowed
- **Aggressive directional weighting:**
  - Closest to player: weight 4 (highest priority)
  - Top-right and top-left: weight 3
  - Bottom-right and bottom-left: weight 2
  - Farthest from player: weight 1
- Strongly favors moving toward player

**Sniper:**
- All 6 directions
- Farthest: weight 4
- Closest: weight 1
- Others: weight 2
- Defensive positioning

### Standoff Mode AI Behavior

**Decision-making (0.5s intervals):**
1. Calculate distance to player
2. Choose movement direction based on AI type:
   - **Basic/Shotgun**: Aggressive - always approach player
   - **Handcannon**: Mid-range - maintain 2-4 unit distance
   - **Sniper**: Defensive - retreat when player gets too close
3. Perform jump checks:
   - Obstacle detection (forward raycast)
   - Edge detection (downward raycast)
   - Gap jumping (far ground check)

---

## Mobile Controls

### Chess Mode
- Touch anywhere on screen
- Swipe in desired direction
- Visual arrow feedback during swipe
- Dead zone: 24 pixels

### Standoff Mode
- **Virtual Joystick**: Movement (left side of screen)
- **Jump Button**: Jump action (right side of screen)
- **Desktop Fallback**: WASD/Arrows + Space

---

## Inspector Configuration

All values are exposed in the Unity Inspector with tooltips:

**Example (PlayerController):**
```csharp
[Header("Chess Mode")]
[Tooltip("Movement animation duration")]
public float moveDuration = 0.12f;

[Header("Standoff Mode Settings")]
[Tooltip("Movement speed in Standoff mode")]
public float standoffMoveSpeed = 5f;

[Tooltip("Jump force")]
public float jumpForce = 10f;
```

---

## Level Configuration

Create new levels using ScriptableObjects:

1. Right-click in Project ‚Üí Create ‚Üí Game ‚Üí Level Data
2. Configure:
   - Grid settings (radius, extraRows, tileSize)
   - Opponent counts (Basic, Handcannon, Shotgun, Sniper)
   - Player HP (starting, max)
   - Platform settings (floorTiles, platformExpansions)
   - Difficulty (fireRate, detectionRange)
   - Audio/Visual (music, skybox)

3. Add to `GameManager.levels[]` array

---

## Performance Considerations

### Optimizations Applied
1. **Script Consolidation**: 27 scripts ‚Üí 15 scripts (44% reduction)
2. **Raycasts**: Limited frequency (AI thinks every 0.5s)
3. **Coroutines**: Used for smooth animations instead of Update loops
4. **Camera bounds caching**: Follow Camera calculates bounds once
5. **Input caching**: InputSystem caches references

### Token Preservation for AI Agents
- **Never read image files**: Sprites, textures, icons
- **Never read audio files**: Music, SFX
- **Only read C# scripts** for code analysis
- **List asset names** without reading content

---

## Common Tasks

### Adding a New AI Type
1. Add enum value to `PawnController.AIType`
2. Add case to `ApplyCombinedWeights()` in `Pawn Controller.cs`
3. Add case to `MakeStandoffDecision()` in `Pawn Controller.cs`
4. Add firing logic to `WeaponSystem.Fire()` method
5. Create prefab with configured `PawnController` and `WeaponSystem`
6. Add to level configuration

### Assigning Modifiers to Opponents
1. **In Code** (via spawner or script):
   ```csharp
   PawnController pawn = GetComponent<PawnController>();
   pawn.SetModifier(PawnController.Modifier.Tenacious);
   ```

2. **In Unity Inspector**:
   - Select opponent pawn prefab or instance
   - In `PawnController` component, set `Modifier` dropdown
   - Assign modifier icon sprites:
     - `Tenacious Icon` (shield/armor sprite)
     - `Confrontational Icon` (sword/aggressive sprite)
     - `Fleet Icon` (speed/wings sprite)
     - `Observant Icon` (eye sprite)
     - `Reflexive Icon` (target/crosshair sprite)
   - Assign `Modifier Icon Image` (UI Image component for display)

3. **Modifier UI Setup**:
   - Create a Canvas child under the pawn GameObject
   - Add UI Image component positioned at top-right of pawn
   - Assign this Image to `PawnController.modifierIconImage`
   - The icon will auto-update when modifier is set

4. **Testing Modifiers**:
   - **Tenacious**: Verify pawn survives first capture, dies on second
   - **Confrontational**: Watch for firing when entering LOS (Chess) or faster firing (Standoff)
   - **Fleet**: Count moves per turn (should be 2 in Chess), check movement speed (Standoff)
   - **Observant**: Verify bullets only damage player in Chess, check firing delay in Standoff
   - **Reflexive**: Watch aim recalculation after player moves (Chess), verify instant tracking (Standoff)

### Adding a New Modifier
1. Add enum value to `PawnController.Modifier`
2. Add sprite field in `PawnController` (e.g., `newModifierIcon`)
3. Add case to `UpdateModifierIcon()` method
4. Implement effects in `ApplyModifierEffects()` method
5. Add multiplier methods if needed (e.g., `GetNewModifierMultiplier()`)
6. Update `WeaponSystem` or other systems to respect new modifier
7. Document in CLAUDE.md

### Adding a New Level
1. Create `LevelData` ScriptableObject
2. Configure all parameters
3. Add to `GameManager.levels[]`
4. Level buttons auto-generate in UIManager

### Using Pawn Customiser to Tweak AI Behavior
The **Pawn Customiser** is a ScriptableObject that centralizes all AI behavior parameters, allowing you to adjust pawn behavior without modifying code.

**Creating a Pawn Customiser:**
1. Right-click in Project window ‚Üí Create ‚Üí Game ‚Üí Pawn Customiser
2. Name it (e.g., "Default Pawn Customiser", "Hard Mode AI", "Easy Mode AI")
3. Assign it to pawn prefabs in the Inspector (`PawnController.pawnCustomiser` field)

**Configurable Parameters:**

1. **Chess Mode Weights** - Control movement priorities for each AI type:
   - **Basic AI**: Weights for closest/other tiles (default: 5/1)
   - **Handcannon AI**: Weights for closest/other tiles (default: 3/1)
   - **Shotgun AI**: Weights for closest/diagonal/side/farthest tiles (default: 4/3/2/1)
   - **Sniper AI**: Weights for farthest/medium/closest tiles (default: 4/2/1)

2. **Standoff Mode Distances** - Control AI positioning preferences:
   - **Aggressive Distance**: Basic/Shotgun approach threshold (default: 1.5)
   - **Handcannon Min/Max**: Optimal distance range (default: 2-4)
   - **Sniper Retreat**: Distance to retreat from player (default: 6)

3. **Modifier Effects** - Adjust modifier multipliers:
   - **Tenacious Max HP**: Health granted by modifier (default: 2)
   - **Confrontational Fire Interval**: Multiplier for fire rate (default: 0.75)
   - **Fleet Move Speed**: Speed multiplier in Standoff (default: 1.25)
   - **Observant Firing Delay**: Delay reduction (default: 0.5)
   - **Reflexive Firing Delay**: Delay reduction (default: 0.75)

4. **Platformer Movement** - Control jumping and movement:
   - **Base Move Speed**: Movement speed before modifiers (default: 3)
   - **Jump Force**: Rigidbody2D jump force (default: 8)
   - **Max Jumpable Height/Gap**: Obstacle/gap jump limits (default: 2/2)
   - **Ground Check Distance**: Raycast distance (default: 0.1)
   - **Edge Check Parameters**: Edge detection settings

5. **AI Thinking** - Control decision-making timing:
   - **Chess Move Animation Duration**: Movement animation time (default: 0.12s)
   - **Standoff Think Interval**: AI decision interval (default: 0.5s)

**Example Use Cases:**
- **Easy Mode**: Lower aggressive AI weights, increase retreat distances, slower movement
- **Hard Mode**: Higher aggressive weights, faster firing rates, increased movement speed
- **Sniper-Focused Level**: Increase sniper retreat distance, reduce other AI aggressiveness
- **Fast-Paced Level**: Lower think intervals, increase movement speeds, faster animations

**Testing Your Customiser:**
1. Create multiple customiser assets with different settings
2. Assign different customisers to different pawn prefabs
3. Test in-game to see behavior differences
4. Iterate on values in Unity Editor (changes apply immediately in Edit mode)

**Fallback Behavior:**
- If `pawnCustomiser` is null, Pawn Controller uses hardcoded default values
- Ensures backward compatibility with existing prefabs

### Adding a New Firearm Mode
1. Add enum value to `WeaponSystem.FireMode`
2. Implement logic in `WeaponSystem.HandleFireModes()`
3. Test in both Chess and Standoff modes

### Modifying Platform Generation
1. Edit `Platform.cs` parameters
2. Adjust `GenerateFloorTiles()` for floor layout
3. Modify `GeneratePlatform()` for platform placement
4. Update `MirrorTiles()` for symmetry rules

---

## Testing Workflow

### Chess Mode Testing
1. Verify hex grid generation
2. Test player swipe movement in all 6 directions
3. Test opponent AI for each type (Basic, Handcannon, Shotgun, Sniper)
4. Verify turn-based system (Checkerboard)
5. Test opponent shooting:
   - Basic: No shooting
   - Handcannon: 1 bullet, 1 damage
   - Shotgun: 3 bullets at 0¬∞/+60¬∞/-60¬∞, 1 damage each
   - Sniper: 1 bullet, 2 damage, pierces once for 1 damage
6. Verify player/opponent capture mechanics
7. Test HP system and death
8. Test modifiers:
   - Tenacious: Pawn survives one capture, dies on second
   - Confrontational: Fires when entering LOS (not yet implemented)
   - Fleet: Moves 2 tiles per turn, shoots only once
   - Observant: Bullets only damage player
   - Reflexive: Recalculates aim after player moves

### Standoff Mode Testing
1. Verify platform generation (symmetry, connectivity)
2. Test player platformer controls (movement, jump)
3. Test opponent AI platforming (jumping, edge detection)
4. Verify slow motion effect (move vs idle)
5. Test shooting mechanics:
   - Interval-based firing (track ‚Üí delay ‚Üí fire ‚Üí repeat)
   - Gun tracking with angular velocity
   - Firing delay hold before shot
6. Verify win condition (touch opponent)
7. Test transition from Chess ‚Üí Standoff
8. Test Basic-to-Handcannon conversion (last opponent)
9. Test modifiers:
   - Tenacious: Takes 2 damage to defeat
   - Confrontational: 25% reduced fire interval
   - Fleet: 25% faster movement
   - Observant: 50% reduced firing delay (0.5s ‚Üí 0.25s)
   - Reflexive: Instant tracking, 25% reduced firing delay

### UI Testing
1. Main menu navigation
2. Level selection
3. In-game HUD updates
4. Pause/resume functionality
5. Victory/defeat screens
6. Settings (volume controls)
7. Mobile controls visibility (auto-detect)

---

## Known Limitations

1. **3 Levels Maximum**: Currently configured for 3 levels
2. **Single Opponent in Standoff**: Only supports 1v1 Standoff
3. **Hex Orientation**: Grid uses FlatTop by default
4. **Physics 2D**: Requires Unity Physics 2D package
5. **TextMeshPro**: UI requires TextMeshPro package

---

## Dependencies

- **Unity Version**: 6000.4.0a4 (Unity 6 Alpha)
- **Required Packages**:
  - TextMeshPro
  - Input System (new)
  - 2D Physics

---

## Code Style

### Naming Conventions
- **Public Fields**: PascalCase
  - Example: `public float MoveSpeed = 5f;`
  - Example: `public Rigidbody2D PlayerRigidBody;`
- **Private Fields**: camelCase
  - Example: `private float moveSpeed = 5f;`
  - Example: `private Rigidbody2D rigidBody;` (not `rb`)
- **Readonly Fields**: snake_case
  - Example: `private readonly float max_speed = 10f;`
  - Example: `private readonly Vector3 default_position = Vector3.zero;`
- **Constants/Static Readonly**: UPPER_CASE_SNAKE_CASE
  - Example: `private const float MAX_SPEED = 10f;`
  - Example: `private static readonly float DEFAULT_SPEED = 5f;`
- **Methods**: PascalCase
- **Regions**: Use `#region` blocks sparingly - limit to one `#region` per 200 lines of code (e.g., a 400-line script should have max 2 regions, 600-line script max 3 regions). Remove #region entirely for scripts under 200 lines.
- **Descriptive Naming**: Prefer full descriptive names over abbreviations
  - Good: `rigidBody`, `mainCamera`, `playerTransform`
  - Avoid: `rb`, `cam`, `pt`
  - Exception: Common Unity abbreviations like `q`, `r` for coordinates are acceptable

### Comments
- **Function/Class Documentation**: Use `///` (triple slash) WITHOUT `<summary>` tags
  - Place above functions and classes to explain their purpose
  - Example: `/// Handles player movement in both Chess and Standoff modes`
  - NOT: `/// <summary>.../// </summary>`
- **Inline Logic**: Use `//` (double slash) for inline comments
  - Single-line comments only (no `/* */` multi-line blocks)
  - First word capitalized
  - Example: `// Calculate distance to player`
- **Comment Style**: Comprehensive and ample
  - Explain how functions and classes work
  - Comment logic flow and important calculations
- **Field Formatting**: Use consistent pattern for all serialized and important fields
  - Pattern: `[Tooltip] ‚Üí // Comment ‚Üí field declaration`
  - Do NOT leave blank lines between variable declarations
  - All [Tooltip] attributes required for Inspector fields
  - Comments explain what the field does and why it matters
  - Example (Serialized Fields):
    ```csharp
    [Header("Current State")]
    [Tooltip("Current game state (viewable in inspector)")]
    // Current game state for state machine management.
    [SerializeField] private GameState currentState = GameState.MainMenu;

    [Header("References")]
    [Tooltip("Reference to the grid generator")]
    // Hex grid generator for board creation and tile lookup.
    [SerializeField] private HexGridGenerator gridGenerator;
    ```
  - Example (Private Fields):
    ```csharp
    // Singleton instance for easy access.
    public static GameManager Instance { get; private set; }
    // Currently loaded level data.
    private LevelData currentLevelData;
    // Current level index.
    private int currentLevelIndex = 0;
    ```
- **Focus**: Comments explain the "why" and "how", not just the "what"

### Unity-Specific
- **Inspector Fields**: All serialized fields must have [Tooltip] attributes
- **SerializeField**: Use for private Inspector-visible fields
  - Example: `[SerializeField] private float moveSpeed = 5f;`

### Unity 6 Compatibility
- **Rigidbody2D**: Use `linearVelocity` and `angularVelocity` (NOT `velocity`)
- **Physics**: Follow Unity 6 API conventions
- **Deprecated APIs**: Always use the latest Unity 6 equivalents

### Code Organization
- Group related fields with [Header] attributes
- Use [SerializeField] for private Inspector-visible fields
- Maintain logical region organization:
  - Enums and Types
  - Inspector Fields
  - Private Fields
  - Properties
  - Unity Lifecycle (Awake, Start, Update, etc.)
  - Public Methods
  - Private Methods
  - Event Handlers

---

## Debugging Tips

### Chess Mode Issues
- Check `Checkerboard.IsPlayerTurn()` for turn management
- Verify hex coordinates with `Debug.Log($"q={q}, r={r}")`
- Use `showDebug` flags in controllers
- Check tile names: "Hex_{q}_{r}"

### Standoff Mode Issues
- Verify Rigidbody2D configuration (non-kinematic, gravity=2)
- Check ground layer mask settings
- Test ground detection raycasts (enable Gizmos)
- Verify TimeController.Instance is active

### UI Issues
- Check singleton initialization order
- Verify UnityEvent connections in Inspector
- Test with both mobile and desktop input

---

## Future Enhancement Ideas

1. **More AI Types**: Add specialized behaviors
2. **Power-ups**: Chess mode pickups
3. **Modifiers**: "Fights in Tight Spaces" style modifiers
4. **More Levels**: Expand beyond 3 levels
5. **Multiplayer**: Local or online
6. **Procedural Levels**: Random hex grid layouts
7. **Boss Battles**: Multi-phase Standoff encounters
8. **Replay System**: Record and replay games

---

## Contact & Attribution

This project was developed as a prototype for a 2D Mobile Game Development assignment.

**Game Inspirations:**
- **Shotgun King: The Final Checkmate** - Chess + Shooting mechanics (reversed concept)
- **Fights in Tight Spaces** - Enemy modifiers and tactical gameplay
- **SUPERHOT** - Time manipulation mechanics (time moves when you move)
- **Terraria** - Side-scrolling platformer combat style

---

*Last Updated: 2025-12-10*
*Unity Version: 6000.4.0a4*
*Total Scripts: 16 (Consolidated)*
*Total Lines of Code: 6000+*
*Modifiers: 5 (Tenacious, Confrontational, Fleet, Observant, Reflexive)*
